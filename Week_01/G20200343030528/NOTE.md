#学习笔记
##链表：
*通过 指针 将一组 零散的内存块串联起来使用， 因此只要剩余总内存大于100MB，就可以申请成功，但是列表不能，因为列表使用的是连续的内存块

*分类： 单链表，双链表，循环列表

######单列表
第一个节点：头节点（记录链表的基地址）
最后一个节点：尾节点：指向一个空地址null（表最后一个节点）

时间复杂度
单链表： 插入删除操作都是O(1)，因为只需要考虑相邻节点的指针改变，但实际操作中需要遍历操作的元素在哪个位置，因此在实际操作中时间上是需要O(n)的时间复杂度

随机访问第k个元素，由于需要根据一个节点一个节点的找，因此需要O(n)

循环链表： 头尾相连就是循环链表 如果需要处理的数据具有环状结构，就适合循环链表。

双向链表： 不止有一个后继指针next，还有一个前驱指针prev，因此支持双向遍历，但是多使用了空间。 而这个思想是在之后经常用到的。 空间换时间。

双向链表针对单向链表的优势： 如果删除给定指针指向的节点的话，单向链表没有存贮前驱节点，因此为了找到这个前驱节点，我们还是要遍历，时间复杂度为O(n)而双向链表存贮了，在这个时间复杂度上是O(1).


栈： 放盘子，后放者先拿走，先放者后拿走
操作受限，只允许再一段插入或者删除数据
因此可以推出使用场景： 当某个数据集合只涉及再一段插入和删除设局，并且满足后进先出，先进后出的特性，我们首选该结构

空间复杂度O(1)
注： 空间复杂度是指除了原本得数据存储空间外，算法运行还需要额外的存储空间
时间复杂度：只要是栈顶个别数据得操作，时间复杂度都是O(1)

支持动态扩容得顺序栈：
当原来得栈满了便申请一个更大得数组并copy过去
因此出栈得时候，不会设计内存和数据的搬移，复杂度为O(1),但是入栈得时候略有不同，如果又空闲空间也是O(1)，而满栈得话，需要新申请内存和数据搬移，此时得时间复杂度变成了O(n)

均摊时间复杂度一般都等于最好情况时间复杂度。
