一、TwoNumes之和
1.暴力法
使用两层循环，外层循环计算当前元素与 targettarget 之间的差值，内层循环寻找该差值，若找到该差值，则返回两个元素的下标。
时间复杂度：O(n^2)。
2.使用哈希表
首先梳理一下问题，要找出数组中的元素==差值(target-num)的下标
那么差值到底是多少呢？明显差值是随数组中元素的不同而不同的，那么我们就可以用一个哈希表将这些差值保存下来，注意，保存的是差值
key为差值，value为下标，而这个下标是构成该差值的数组中两个元素中的一个，那么另外一个就可以通过for循环遍历得到，只要这个元素的值等于哈希表中的key。



二、环形队列（循环队列）主要概念
先进先出
capacity：数组容量
front：表示队列队首，始终指向队列中的第一个元素（当队列空时，front指向索引为0的位置）
tail：表示队列队尾，始终指向队列中的最后一个元素的下一个位置
元素入队，维护tail的位置，进行tail++操作，计算公式：(tail + 1) % capacity
元素出队，维护front的位置，进行front++操作，计算公式：(front + 1) % capacity
在循环队列中，总是浪费一个空间，来区分队列为满时和队列为空时的情况，也就是当 (tail + 1) % capacity == front的时候，表示队列已经满了，当front == tail的时候，表示队列为空。


三、heapq的源码：
优先级队列
堆是a[k]<=a[2*k+1]和a[k]<=a[2*k+2]的数组

所有k，从0开始计算元素。为了比较，

不存在的元素被认为是无限的。有趣的

堆的属性是[0]始终是它的最小元素。

函数解释：

heap=[]#创建空堆

heappush(heap, item)#在堆上推送新项

item=heappop（heap）#弹出堆中最小的项

item=heap[0]#堆中最小的项，不弹出它

heapify（x）在线性时间内将列表转换为堆

item=heapreplace（heap，item）#弹出并返回最小的item，然后添加

