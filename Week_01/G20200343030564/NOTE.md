学习笔记-Week01总结

本周学习：数组、链表、栈、队列、双端队列

1.数组和链表比较：
(1)如果按照位置访问的时候，数组的查询效率是为O(1)的，在没有没有告诉位置，只给出值的情况下，数组的访问效率也是O(n)的，因为最坏的情况这个值
可能在数组的最后面，所以要遍历整个数组。数组的插入和删除操作要移动数组，所以时间复杂度为O(n)。
(2)如果链表的遍历时是按照次数遍历的，那链表的时间复杂度也是O(1)的。单纯的链表插入和删除操作是O(1)的，但遍历查找的时间是主要的耗时点，
对应的时间复杂度为O(n)。

2.栈和队列的比较：
(1)栈是先进后出(类比叠盘子)。可以使用两个队列来实现栈，表现入栈时候，就把元素放入队列中，出栈的时候，把第一个队列的元素放入第二个队列中，
然后遍历第二个队列，就能实现栈的现金后出的方法。
(2)队列是先进先出(类比排队)。可以使用两个栈来实现一个队列，表现入队列时候，就把所有的元素放在第一个栈中，出队列的时候，把第一个栈里面的
元素压到第二个元素中，然后迭代第二个栈，实现队列的出列。

3.LeetCode刷题心得：
(1)数组题目：一般方法是双指针方法，但是在26题中，有个前插法比较优美，就是在除去重复元素的时候，用一个i来计数。如果当前元素比i位置的
前一个元素大，则插在i位置上，返回i的值就是出重的数组长度。

(2)链表的题目：一般都是两种方法：迭代和递归，在做题的时候要注意定义一个头结点，这个头结点是返回值，返回后程序可以遍历这个头结点迭代
新的链表，也要注意指针的指向问题，不要丢失引用。

(3)对于面积的算法题目：首选方法是双指针夹逼准则，循环计算前后所夹的面积，当两个指针相遇的时候循环结束。

(4)特别分享(因为找了很多资料都没有说明白这个解法)：
旋转数组中的使用环状替换解法：
private static void rotate(int[] nums, int k) {
    /**
     * k % nums.length 当k等于数组长度的时候，摸出来的值为0，当k为[0,nums.length)中，或者是区间的倍数，摸出来的值都是一样的，就是
     * 数组要旋转到的位置。
     */
    // 基于上面所说， k = k % nums.length 代码可要可不要。
    k = k % nums.length;
    // count 是记录移动元素的个数，每个元素都要移动，循环才会结束。
    int count = 0;
    for (int start = 0; count < nums.length; start++) {
        int current = start;
        int prev = nums[start];
        /** 
         * 查找到循环的位置，然后把当前数组元素放到要循环的位置，缓存要循环的位置的原始值。
         * 因为每次next增加的次数是有规律的步长，所以循环几次就会回到起始位置，比如说start = 0 ，current = 0, 循环一次后 current 
         * 发生变化，但是多次后next = 0 , current就会等于0，退出循环。然后在从start = 1的位置开始。
         */
        do {
            int next = (current + k) % nums.length;
            int temp = nums[next];
            nums[next] = prev;
            prev = temp;
            current = next;
            count++;
        } while (start != current);
    }
 }
 
 4.Queue 和 Priority Queue源码分析放在另外的文件中