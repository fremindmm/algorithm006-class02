##作业

#### 字典树
- [#208. Implement Trie (Prefix Tree)](./Leetcode-208-380.js)
- [#212. Word Search II](./Leetcode-212-380.js)

#### 并查集、DFS、BFS
- [#547. Friend Circles](./Leetcode-547-380.js)
- [#200. Number of Islands](./Leetcode-200-380.js)
- [#130. Surrounded Regions](./Leetcode-130-380.js)
- [#36. Valid Sudoku](./Leetcode-36-380.js)

##学习笔记

### Trie树（字典树）

- 字典树的应用场景
    - 统计和排序大量字符串（但不仅限于字符串）
    - 拼写检查
    - 文本词频统计
    - 根据前缀自动联想出可能要搜索的词
- 字典树的基本性质
    - 结点本身不存完整单词
    - 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串
    - 每个结点的所有子结点路径代表的字符都不相同
    - 最大限度地减少无谓的字符串比较，查询效率比哈希表高
    - 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的
    - 核心思想：空间换时间

### 并查集（Disjoint Set）

- 是一种树形的数据结构，用来处理一些不相交集合(Disjoint Sets)的合并与查询问题
- 适用场景
    - 组团，配对问题
- 联合-查找算法（union-find algorithm），是此数据结构的基本操作
    - Create: 初始化时，每个元素是一个集合，且自己是集合代表，我为自己代言
    - Find：确定元素属于哪个子集，找到它的集合代表
    - Union：将两个子集合并成一个集合
- 代码模版

        // 包含路径压缩优化: 处于同一路径上的节点都直接连接到根节点
        let makeSet = (x) => { parent[x] = x }
        let find = (x) => {
        	while(parent[x] != x) {
        		parent[x] = parent[parent[x]]
        		x = parent[x]
        	}
        	return x i
        }
        let union = (x, y) => {
        	let rootX = find(x), rootY = find(y)
        	if (rootX === rootY) return
        	parent[rootX] = rootY
        }

### 高级搜索

何谓高级搜索，其实就是在初级搜索（暴力搜索）的基础上做优化，主要是两个方向的优化

- 剪枝：减少不必要的搜索次数
    - fibonacci数列中的避免重复计算大家应该还有印象，这就是剪枝
    - 生成括号问题中的左括号要小于n，右括号要小于左括号，也是剪枝
    - 八皇后问题中的 pie, na 的判断，也是剪枝
- 方向：找到更合理的搜索方向
    - DFS：深度优先搜索
    - BFS：广度优先搜索
    - 双向搜索（双向BFS）
        - 起点和终点同时做广度优先搜索
    - 启发式搜索（A* Search）
        - 使用优先队列
        - 根据优先级顺序进行搜索
        - 估价函数（启发式函数）：用来评价哪些结点更有希望导向结果，返回一个非负实数，表示从该结点到目标结点的路径的估计成本

### AVL 树

- 二叉搜索树的查询复杂度是基于树的深度的（log2n)；所以深度越小，查询越快
- 每个结点都会存储一个平衡因子(Balance Factor):  左右子树的高度差，取值范围：{ -1, 0, 1 }
    - 每个结点的平衡因子需要维持在 -1 0 1 之间，如果超过了就需要通过旋转操作来进行平衡
- 通过旋转操作来进行平衡
    - 左旋
    - 右旋
    - 左右旋
    - 右左旋
- 缺点：结点需要存储额外信息，且调整次数频繁

### 红黑树

- 是一种近似平衡的二叉树，它只要求确保任何一个结点的左右子树的高度差小于2倍
- 每个结点要么是红色，要么是黑色
- 根结点是黑色
- 每个叶结点(nil结点，空结点)是黑色
- 不能有相邻接的两个红色结点
- 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

### AVL树与红黑树对比

- AVL树的查询效率由于红黑树（因为AVL树是严格平衡的二叉树，红黑树是近似平衡）
- 红黑树的插入/删除效率由于AVL树（因为红黑树只要做到近似平衡就可以了，所以有更少的旋转操作）
- AVL树需要更多的存储空间，每个结点都要存储一个Integer类型的平衡因子，而红黑树每个结点只需要 1 bit 来存0或1表示黑红即可
- AVL树在DB里用的比较多，因为数据库一般读操作更多；红黑树在高级语言库用的比较多，Map，Set，因为写操作更多，而且相对来说容易实现一些

