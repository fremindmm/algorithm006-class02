# 高级动态规划

DP的题目，还是不能上手。一道题目，一道题目反复看题解，才能理解，现在就死办法，几道题反复刷反复写，增加题感。

```
function DP();
	dp = [][] # 二维情况
  for i = 0 .. M {
    for j = 0 .. N {
      dp[i][j] = _Function(dp[i'][j']...)
    }
  }
```

# 字符串

## 暴力法

## Rabin-Karp 算法

- 1. 假设子串的长度为 M (pat)，目标字符串的长度为 N (txt)
- 2. 计算子串的 hash 值 hash_pat
- 3. 计算目标字符串txt中每个长度为 M 的子串的 hash 值（共需要计算 N-M+1次）
- 4. 比较 hash 值：如果 hash 值不同，字符串必然不匹配; 如果 hash 值相同，还需要使用朴素算法再次判断

## KMP 算法

KMP算法（Knuth-Morris-Pratt）的思想就是，当子串与目标字符串不匹配时，其实你已经知道了前面已经匹配成功那 一部分的字符（包括子串与目标字符串）。以阮一峰的文章为例，当空格与 D 不匹配时，你其实 知道前面六个字符是“ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把“搜索位置” 移回已经比较过的位置，继续把它向后移，这样就提高了效率
