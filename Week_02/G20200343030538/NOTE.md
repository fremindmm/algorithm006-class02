### 学习笔记  

#### 散列表  
散列表(Hash Table)，也叫哈希表，是根据关键码值而直接进行访问的数据结构，通过把关键码值映射到表中一个位置来访问记录，用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。  

这个映射函数叫散列函数，存在记录的数组叫散列表或哈希表。  

#### 散列冲突  
常用的散列冲突解决方法有两类，开放寻址法和链表法。  

1、开放寻址法。核心思想是如果出现了散列冲突，就重新探测一个空闲位置，将其插入。当数据量比较小、装载因子小的时候，适合采用开放寻址法。  
 - 比较简单的探测方法: 线性探测  
 - 两种比较经典的探测方法，二次探测、双重散列  
 
线性探测是比较简单的探测方法，当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。  

线性探测每次探测的步长是1，二次探测探测的步长就变成了原来的"二次方";  

双重散列意思就是不仅要使用一个散列函数。使用一组散列函数hash1(key)，hash2(key)，hash3(key)...先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。  

2、链表法。是一种更加常用的散列冲突解决办法。基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。  
![list_01](https://github.com/HinataHoshino/algorithm006-class02/blob/master/Week_02/G20200343030538/image/list_01.jpg)  

#### 装载因子  
不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少  
```
散列表的装载因子=填入表中的元素个数/散列表的长度
```
装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。  

#### 哈希算法的应用  
哈希算法分别是: 
- 安全加密  
- 数据校验  
- 唯一标识  
- 散列函数  
- 负载均衡  
- 数据分片  
- 分布式存储  

#### 二叉树的遍历  
经典的方法有三种:  
 - 前序遍历  
 - 中序遍历  
 - 后序遍历  

其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。  
![binary_tree traversal](https://github.com/HinataHoshino/algorithm006-class02/blob/master/Week_02/G20200343030538/image/binary_tree_traversal.jpg)  

#### 二叉搜索树  
二叉搜索树，又称二叉搜索排序树、有序二叉树，是指一颗空树或者具备下列性质的二叉树:  
1、左子树上**所有结点**的值均小于它的根结点的值;  
2、右子树上**所有结点**的值均小于它的根结点的值;  
3、以此类推: 左、右子树也分别为二叉查找树。  

是中序遍历是升序遍历  
