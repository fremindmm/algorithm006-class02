学习笔记
HashMap小总结
概述：
HashMap是基于哈希表，实现Map接口的双列集合，底层结构为：数组+链表，Key唯一Value可以重复，允许存储Null键Null值
数据结构：
HashMap的底层是一个数组，数组中每一项元素又是一个链表，当HashMap进行数据初始化的时候，会创建一个Entry数组
默认大小16，Entry结构中包含key,value,next指针(指向下一个元素的引用)
HashMap存储：
调用put()方法,key先经过Hash函数进行计算hash值，根据hash值，可以获得在数组中的位置，也就是数组的下标，关键代码：(p = tab[i = (n - 1) & hash]) == null；如果该位置没有元素，则新构建一个Entry
如果该位置有元素，且Key相等，则以链表的形式添加，如果达到8个元素，则转化为红黑树形式，添加完Entry后，重新判断该数组是否达到扩容阀值，已达则需要进行扩容
HashMap读取：
调用get()方法，首先计算Key的hash值，找到数组中对应位置table[i],再优先查看首节点是不是符合条件，不符合条件的情况下，判断是链表还是红黑树结构，再判断Key是否相等
HashMap的hash计算：
 (h = key.hashCode()) ^ (h >>> 16)
 通过异或运算，可以将hashcode高位和低位的值进行混合，增大生成的hash值的随机性
HashMap的resize()扩容
 resize()方法在size>threshold时被调用，newCap = oldCap << 1，同时oldTab中的节点，要reHash到newTab中，同时，红黑树的rehash操作与链表的rehash操作不一样，
 链表rehash，根据算法 e.hash & oldCap 判断节点位置rehash后是不是发生了变化，在扩充HashMap的时候，
 只需要看看原来的hash值新增的bit位置是1还是0，是0的话，索引位置不变，是1的话索引变成“原索引+oldCap”
 
HashMap是线程不安全的
  场景：多线程执行put的时候会导致的数据不一致
        两个线程同时进行resize,同时修改一个链表结构会产生循环链表，因为在调整大小的过程中，存储在链表中的元素次序会反过来，放在头部，这样设计是为了避免尾部遍历，但是同时resize会构成死循环
        
   
HashMap的tabSizeFor()方法解析
返回一个比给定整数大且最接近2的幂次方的整数，比如给定10，则返回16
HashMap要求容量必须是2的幂，
首先int n=cap-1;是为了防止cap已经是2的幂时，执行完后面的几个无符号右移动操作之后，返回的capacity是现有cap的两倍，因为cap已经是2的幂了，已经满足条件了，

HashMap为什么容量必须是2的幂？
假设容量是15，在使用h&(length-1)的时候，会很容易出现一样的二进制数，如8和9，计算完都是1000 1000，这样就降低了哈希表的查询效率，同事长度为15，容易造成个别位置一直存取不到数据，造成空间浪费，可用长度变小，则加剧了hash碰撞的几率，使用
2的n次方的时候，扩容后只会只会有一个bit位的差距，便于进行数据迁移，且数据分布均匀，减少碰撞几率
