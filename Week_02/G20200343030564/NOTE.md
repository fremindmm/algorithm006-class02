学习笔记-Week02总结

本周学习：哈希表、二叉树、递归

哈希表:英文叫"Hash Table",散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。再完美的
哈希函数，无法完全避免这种散列冲突。解决哈希冲突的方法有两种开放寻址法、链表法和双重散列法，其中链表法使用比较广。在没有冲突的情况下
哈希算法查找到值的时间复杂度是 O(1)，最坏情况下查找会形成链表，时间复杂度就为O(n)。哈希的运用MD5、SHA、CRC等等。

递归做题四步曲：
1.terminator 终止条件
2.Process Logic 程序逻辑
3.Drill Down 下沉
4.reverse status 返回

二叉树：
二叉树的遍历：时间复杂度是 O(n)
前序遍历：根左右
中序遍历：左根右
后序遍历：左右根

满二叉树：
叶子节点全部都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树叫满二叉树。

完全二叉树：
叶子节点全部都在最底层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数全部都要达到最大。


解题总结：
递归解题：运用数学归纳法找到规律，在用做题四步曲写好框架，因为递归会做些重复的工作，所以运用好缓存很重要。

哈希表解题：哈希的查询比较快，所以对于有规律的题，首先要缓存规律，然后再在数组中找到符合规律的值的这类题目比较适用。

二叉树解题：
前序遍历：根左右的规律，先找出根的值，再在迭代出左边的值，再到右边的值。栈这种数据结构比较方便解题。
中序遍历：左根右，先把左边的值全部找出放入栈中，然后到根，再到右边的值。
后序遍历：左右根，在前序遍历的基础上，运用双端链表的头插法，输出的值就是后序遍历的值。

N叉树：
前序遍历：根左右。子链表从后往前压入双端队列。
中序遍历：左根右。
后序遍历：左右根。子链表从前往后压入双端队列。

注意要子链表会不会为空，要进行判空。
