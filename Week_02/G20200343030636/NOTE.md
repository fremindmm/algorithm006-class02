学习笔记
Hash：原理上通过hash函数把一个散列映射到另一个有限集合，运算过程常常包含数学计算。有数学原理支撑。会存在2个不同的元素映射到同一个元素，称为hash冲突，
	解决冲突到办法有以下几种办法
	A）：开放定址法：从发生冲突的那个单元起，按照一个规则，从哈希表中找到一个空的单元。然后把发生冲突的元素存入到该单元。具体的方法有：线行探查法、平方探查法、双散列函数探查法。
	B）：拉链法：将冲突的元素构成一个链表。当hash函数散列得不够均匀时，冲突增加，链表变长，会导致查询效果变低，不再是常数级
    1）查询：通过key查询的时间复杂度为O(1)，遍历整个hash的复杂度是O(n)
    2）增加/删除：大部分情况下插入或者删除复杂度为O(1)，当对有冲突对元素处理时，时间复杂度取决于冲突对处理，整体平均复杂度仍然是O(1)
    3）修改：按Key进行修改的时间复杂度为O(1)；
    4）C++中常用unordered_map来表示hash，其内部使用对hash函数可以用成员函数hash_function来获取，通常C++11使用的这个算法会依赖编译器的实现，例如GCC实现了C++11的11个散列函数，对于字符串，使用的是MurmurHashUnaligned2散列算法
       在文件gcc/libstdC++ - v3/libsupC++/hash_bytes.cc中能找到这些hash function
Set	：唯一性集合，内部通常是在hash的基础上实现的，value值通常用null来表示
    1）查询：通过key查询的时间复杂度为O(1)，遍历整个hash的复杂度是O(n)
    2）增加/删除：复杂度为O(1)
    3）修改：按Key进行修改的时间复杂度为O(1)；
    4）C++中常用unordered_set来表示集合，内部是在unordered_map基础上来实现的
二叉树：每个节点最多有2个子树的树结构；通常用于实现二叉搜索树或者二叉堆。有完全二叉树，满二叉树，平衡二叉树，红黑树等各种特定规则的树；其中满二叉树或者完全二叉树能用数组来表示，其他的只能通过递归的树结构来表示

二叉搜索树：特定规则的二叉树；它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。
平衡二叉树：为了解决二叉搜索树最坏当情况下操作复杂度从O(longN)退化到O(n)，定义了新到规则，每个节点到左右子树到高度差不能超过1。优点是解决了退化问题，缺点是插入/删除时为了保持平衡，必须做调整。复杂度增高
红黑树：为了解决平衡二叉树写操作带来到复杂度增加，制定了新到规则，不必严格遵守高度平衡。兼顾了查找效率到稳定性和写操作到稳定性，是实际应用中使用最多到数据结构
    1）查询：平均复杂度O(logN)
    2）增加/删除/修改：平均复杂度近似O(logN)（存在红黑节点的调整）
    4）C++中map内部使用红黑树的数据结构，用于查找和排序。set是基于map实现的有序集合。Linux下epoll的实现内部也使用了红黑树的结构，用于存储要监控的所有socket句柄
二叉搜索树，平衡二叉树，红黑树的中序遍历会得到一个升序的序列。
递归：递归是把问题缩小规模重复性解决的一种方式。