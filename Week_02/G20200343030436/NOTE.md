学习笔记
关于 HashMap 的总结：
它是统一通过hash函数把里面的值来映射到一个位置 int的下标即可 
它是以键值对形式进行存储和操作数据的容器
它与HashTable都是哈希表实现的 但是HashMap是不能同步的，支持null键和值的
它的put get操作是达到常数时间性能
它是绝大部分利用键值对存取场景的首选
Map的整体结构 是有序数据结构
它的设计和实现要点 理解容量，负载因子 对于Map性能的影响 实践中是如何取舍
树化改造的原理和改进原因
HashMap并发环境 无限循环占用CPU size不准确的问题要注意
HashMap是线程不安全的
HashMap的性能表现依赖于哈希码的有效性， hashCode equals要知道
equals相等 hashCode一定相等
重写hashCode后那么也要重写equals
hashCode需要保持一致性 状态改变返回的哈希值仍然要一致
equals的对称 反射 传递特性
HashMap的内部实现结构 可以概括为 数组和链表结合组成的复合结构
数组被分为一个个桶 通过哈希值决定了键值对在这个数组的寻找
哈希值相同的键值对 会依链表形式存储 链表的大小超过阈值 就会为了优化性能 被改造成树形结构
从源码实现中可以看出 hashmap 数组在非拷贝构造函数实现中并没有最初就初始化好只是一些初始值的设置
从put方法的内部实现 putVal（hash（key），key，value，false，true）的内部调用上可以知道 resize负责初始化 创建初始存储表格，在容量不满足需求时 进行扩容 
门限值 是负载因子*容量 如果元素个数超过这个值 会调整Map大小
扩容后要将老数组元素重新放置到新数组中所以扩容是会有一定开销的
负载因子的初始值不要随意修改 默认值是一个符合通用场景的。
如果太大 会显著增加冲突，降低hashmap性能
如果太小 会有时候造成频发扩容增加无谓的开销也会影响性能
hashmap的树化是为了 当一个对象哈希冲突 都放置到同一个桶里的话 形成了一个足够长的链表 链表的查询是线性的那么就会严重影响存取的性能 而采取树化的


LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。 它是支持LRU缓存淘汰机制的


链表和数组
数组占据随机访问的优势，却有需要连续内存的缺点。
链表具有可不连续存储的优势，但访问查找是线性的。
散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。
数据结构和算法的重要性排行榜：连续空间 > 时间 > 碎片空间。


队列 优先队列

队列是先进先出的数据结构，而优先队列为元素赋予优先级，具有最高优先级的元素成为队列首部。

优先队列一般基于二叉堆实现。
二叉堆的基本原理：
完全二叉树
堆的根节点的优先级最大（即最大或最小）
父节点的优先级必定大于子节点，兄弟节点的优先级不确定谁大谁小
	时间复杂度
插入	O(logN)
删除	O(logN)
构造	O(N)
堆的用途
取最值

1. 插入
往堆插入元素，基本思想是从最后一个位置开始，通过上浮操作不断调整位置，直到满足父节点的优先级必定大于子节点这个条件。

上浮
上浮是往二叉堆添加元素用到的操作，它其实是不断的调整k的位置为父元素的位置直到满足条件为止。
2. 删除
删除指定位置的元素，其基本思想是从指定位置开始，把最后一个元素放到被删除元素的位置，通过下沉或者上浮操作，使得堆满足父元素优先级大于子元素的条件。

下沉
下沉是删除时用到的操作。它是把最后一个元素放到被删除元素的位置，然后重新调整使得堆满足条件的过程。

当被删除元素的位置位于最后一个元素的父元素的位置后面时，可以直接把最后一个元素插入到被删除元素的位置；然后再进行上浮操作。
否则，需要执行下沉操作。

优先队列
优先队列PriorityQueue是基于二叉堆原理的优先队列，队列用动态数组实现。
它是非阻塞的、非线程安全的；